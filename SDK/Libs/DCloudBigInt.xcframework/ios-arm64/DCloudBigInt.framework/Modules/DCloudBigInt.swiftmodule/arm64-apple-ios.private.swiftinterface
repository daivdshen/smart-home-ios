// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios9.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name DCloudBigInt
// swift-module-flags-ignorable: -enable-bare-slash-regex
@_exported import DCloudBigInt
import Foundation
import Swift
import _Concurrency
import _StringProcessing
extension DCloudBigInt.BigUInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
extension DCloudBigInt.BigInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
extension DCloudBigInt.BigUInt {
  public func greatestCommonDivisor(with b: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
  public func inverse(_ modulus: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt?
}
extension DCloudBigInt.BigInt {
  public func greatestCommonDivisor(with b: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public func inverse(_ modulus: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt?
}
public struct BigUInt : Swift.UnsignedInteger {
  public typealias Word = Swift.UInt
  public init()
  public init(words: [DCloudBigInt.BigUInt.Word])
  public typealias Magnitude = DCloudBigInt.BigUInt
}
extension DCloudBigInt.BigUInt {
  public static var isSigned: Swift.Bool {
    get
  }
  public var isZero: Swift.Bool {
    get
  }
  public func signum() -> DCloudBigInt.BigUInt
}
extension DCloudBigInt.BigUInt {
  prefix public static func ~ (a: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
  public static func |= (a: inout DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt)
  public static func &= (a: inout DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt)
  public static func ^= (a: inout DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt)
}
extension DCloudBigInt.BigInt {
  prefix public static func ~ (x: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func & (lhs: inout DCloudBigInt.BigInt, rhs: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func | (lhs: inout DCloudBigInt.BigInt, rhs: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func ^ (lhs: inout DCloudBigInt.BigInt, rhs: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func &= (lhs: inout DCloudBigInt.BigInt, rhs: DCloudBigInt.BigInt)
  public static func |= (lhs: inout DCloudBigInt.BigInt, rhs: DCloudBigInt.BigInt)
  public static func ^= (lhs: inout DCloudBigInt.BigInt, rhs: DCloudBigInt.BigInt)
}
extension DCloudBigInt.BigUInt : Swift.Comparable {
  public static func compare(_ a: DCloudBigInt.BigUInt, _ b: DCloudBigInt.BigUInt) -> Foundation.ComparisonResult
  public static func == (a: DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt) -> Swift.Bool
  public static func < (a: DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt) -> Swift.Bool
}
extension DCloudBigInt.BigInt : Swift.Comparable {
  public static func == (a: DCloudBigInt.BigInt, b: DCloudBigInt.BigInt) -> Swift.Bool
  public static func < (a: DCloudBigInt.BigInt, b: DCloudBigInt.BigInt) -> Swift.Bool
}
extension DCloudBigInt.BigUInt {
  public func quotientAndRemainder(dividingBy y: DCloudBigInt.BigUInt) -> (quotient: DCloudBigInt.BigUInt, remainder: DCloudBigInt.BigUInt)
  public static func / (x: DCloudBigInt.BigUInt, y: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
  public static func % (x: DCloudBigInt.BigUInt, y: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
  public static func /= (x: inout DCloudBigInt.BigUInt, y: DCloudBigInt.BigUInt)
  public static func %= (x: inout DCloudBigInt.BigUInt, y: DCloudBigInt.BigUInt)
}
extension DCloudBigInt.BigInt {
  public func quotientAndRemainder(dividingBy y: DCloudBigInt.BigInt) -> (quotient: DCloudBigInt.BigInt, remainder: DCloudBigInt.BigInt)
  public static func / (a: DCloudBigInt.BigInt, b: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func % (a: DCloudBigInt.BigInt, b: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public func modulus(_ mod: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
}
extension DCloudBigInt.BigInt {
  public static func /= (a: inout DCloudBigInt.BigInt, b: DCloudBigInt.BigInt)
  public static func %= (a: inout DCloudBigInt.BigInt, b: DCloudBigInt.BigInt)
}
extension DCloudBigInt.BigUInt {
  public mutating func subtractReportingOverflow(_ b: DCloudBigInt.BigUInt, shiftedBy shift: Swift.Int = 0) -> Swift.Bool
  public func subtractingReportingOverflow(_ other: DCloudBigInt.BigUInt, shiftedBy shift: Swift.Int) -> (partialValue: DCloudBigInt.BigUInt, overflow: Swift.Bool)
  public func subtractingReportingOverflow(_ other: DCloudBigInt.BigUInt) -> (partialValue: DCloudBigInt.BigUInt, overflow: Swift.Bool)
  public mutating func subtract(_ other: DCloudBigInt.BigUInt, shiftedBy shift: Swift.Int = 0)
  public func subtracting(_ other: DCloudBigInt.BigUInt, shiftedBy shift: Swift.Int = 0) -> DCloudBigInt.BigUInt
  public mutating func decrement(shiftedBy shift: Swift.Int = 0)
  public static func - (a: DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
  public static func -= (a: inout DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt)
}
extension DCloudBigInt.BigInt {
  public mutating func negate()
  public static func - (a: DCloudBigInt.BigInt, b: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func -= (a: inout DCloudBigInt.BigInt, b: DCloudBigInt.BigInt)
}
extension DCloudBigInt.BigUInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension DCloudBigInt.BigInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension Swift.String {
  public init(_ v: DCloudBigInt.BigUInt)
  public init(_ v: DCloudBigInt.BigUInt, radix: Swift.Int, uppercase: Swift.Bool = false)
  public init(_ value: DCloudBigInt.BigInt, radix: Swift.Int = 10, uppercase: Swift.Bool = false)
}
extension DCloudBigInt.BigUInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension DCloudBigInt.BigInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension DCloudBigInt.BigUInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DCloudBigInt.BigInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DCloudBigInt.BigUInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
extension DCloudBigInt.BigInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
extension DCloudBigInt.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
}
extension DCloudBigInt.BigInt {
  public init()
  public init(_ integer: DCloudBigInt.BigUInt)
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
}
extension DCloudBigInt.BigUInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.UInt64)
  public typealias IntegerLiteralType = Swift.UInt64
}
extension DCloudBigInt.BigInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int64)
  public typealias IntegerLiteralType = Swift.Int64
}
extension DCloudBigInt.BigUInt {
  public mutating func multiply(byWord y: DCloudBigInt.BigUInt.Word)
  public func multiplied(byWord y: DCloudBigInt.BigUInt.Word) -> DCloudBigInt.BigUInt
  public mutating func multiplyAndAdd(_ x: DCloudBigInt.BigUInt, _ y: DCloudBigInt.BigUInt.Word, shiftedBy shift: Swift.Int = 0)
  public func multiplied(by y: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
  public static var directMultiplicationLimit: Swift.Int
  public static func * (x: DCloudBigInt.BigUInt, y: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
  public static func *= (a: inout DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt)
}
extension DCloudBigInt.BigInt {
  public static func * (a: DCloudBigInt.BigInt, b: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func *= (a: inout DCloudBigInt.BigInt, b: DCloudBigInt.BigInt)
}
public struct BigInt : Swift.SignedInteger {
  public enum Sign {
    case plus
    case minus
    public static func == (a: DCloudBigInt.BigInt.Sign, b: DCloudBigInt.BigInt.Sign) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias Magnitude = DCloudBigInt.BigUInt
  public typealias Word = DCloudBigInt.BigUInt.Word
  public static var isSigned: Swift.Bool {
    get
  }
  public var magnitude: DCloudBigInt.BigUInt
  public var sign: DCloudBigInt.BigInt.Sign
  public init(sign: DCloudBigInt.BigInt.Sign, magnitude: DCloudBigInt.BigUInt)
  public var isZero: Swift.Bool {
    get
  }
  public func signum() -> DCloudBigInt.BigInt
}
extension DCloudBigInt.BigUInt {
  public func squareRoot() -> DCloudBigInt.BigUInt
}
extension DCloudBigInt.BigInt {
  public func squareRoot() -> DCloudBigInt.BigInt
}
extension DCloudBigInt.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension DCloudBigInt.BigInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension Swift.BinaryFloatingPoint where Self.RawExponent : Swift.FixedWidthInteger, Self.RawSignificand : Swift.FixedWidthInteger {
  public init(_ value: DCloudBigInt.BigInt)
  public init(_ value: DCloudBigInt.BigUInt)
}
extension DCloudBigInt.BigUInt {
  public func isStrongProbablePrime(_ base: DCloudBigInt.BigUInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
extension DCloudBigInt.BigInt {
  public func isStrongProbablePrime(_ base: DCloudBigInt.BigInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
extension DCloudBigInt.BigUInt {
  public func power(_ exponent: Swift.Int) -> DCloudBigInt.BigUInt
  public func power(_ exponent: DCloudBigInt.BigUInt, modulus: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
}
extension DCloudBigInt.BigInt {
  public func power(_ exponent: Swift.Int) -> DCloudBigInt.BigInt
  public func power(_ exponent: DCloudBigInt.BigInt, modulus: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
}
extension DCloudBigInt.BigUInt : Swift.Strideable {
  public typealias Stride = DCloudBigInt.BigInt
  public func advanced(by n: DCloudBigInt.BigInt) -> DCloudBigInt.BigUInt
  public func distance(to other: DCloudBigInt.BigUInt) -> DCloudBigInt.BigInt
}
extension DCloudBigInt.BigInt : Swift.Strideable {
  public typealias Stride = DCloudBigInt.BigInt
  public func advanced(by n: DCloudBigInt.BigInt.Stride) -> DCloudBigInt.BigInt
  public func distance(to other: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt.Stride
}
extension DCloudBigInt.BigInt : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension DCloudBigInt.BigUInt : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension DCloudBigInt.BigUInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DCloudBigInt.BigInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DCloudBigInt.BigUInt {
  public static func randomInteger<RNG>(withMaximumWidth width: Swift.Int, using generator: inout RNG) -> DCloudBigInt.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withMaximumWidth width: Swift.Int) -> DCloudBigInt.BigUInt
  public static func randomInteger<RNG>(withExactWidth width: Swift.Int, using generator: inout RNG) -> DCloudBigInt.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withExactWidth width: Swift.Int) -> DCloudBigInt.BigUInt
  public static func randomInteger<RNG>(lessThan limit: DCloudBigInt.BigUInt, using generator: inout RNG) -> DCloudBigInt.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(lessThan limit: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
}
extension DCloudBigInt.BigUInt {
  public static func >>= <Other>(lhs: inout DCloudBigInt.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout DCloudBigInt.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: DCloudBigInt.BigUInt, rhs: Other) -> DCloudBigInt.BigUInt where Other : Swift.BinaryInteger
  public static func << <Other>(lhs: DCloudBigInt.BigUInt, rhs: Other) -> DCloudBigInt.BigUInt where Other : Swift.BinaryInteger
}
extension DCloudBigInt.BigInt {
  public static func &<< (left: DCloudBigInt.BigInt, right: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func &<<= (left: inout DCloudBigInt.BigInt, right: DCloudBigInt.BigInt)
  public static func &>> (left: DCloudBigInt.BigInt, right: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func &>>= (left: inout DCloudBigInt.BigInt, right: DCloudBigInt.BigInt)
  public static func << <Other>(lhs: DCloudBigInt.BigInt, rhs: Other) -> DCloudBigInt.BigInt where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout DCloudBigInt.BigInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: DCloudBigInt.BigInt, rhs: Other) -> DCloudBigInt.BigInt where Other : Swift.BinaryInteger
  public static func >>= <Other>(lhs: inout DCloudBigInt.BigInt, rhs: Other) where Other : Swift.BinaryInteger
}
extension DCloudBigInt.BigUInt {
  public static func + (a: DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt) -> DCloudBigInt.BigUInt
  public static func += (a: inout DCloudBigInt.BigUInt, b: DCloudBigInt.BigUInt)
}
extension DCloudBigInt.BigInt {
  public static func + (a: DCloudBigInt.BigInt, b: DCloudBigInt.BigInt) -> DCloudBigInt.BigInt
  public static func += (a: inout DCloudBigInt.BigInt, b: DCloudBigInt.BigInt)
}
extension DCloudBigInt.BigUInt {
  public subscript(bitAt index: Swift.Int) -> Swift.Bool {
    get
    set
  }
}
extension DCloudBigInt.BigUInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var leadingZeroBitCount: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension DCloudBigInt.BigInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension DCloudBigInt.BigUInt {
  public struct Words : Swift.RandomAccessCollection {
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> DCloudBigInt.BigUInt.Word {
      get
    }
    public typealias Element = DCloudBigInt.BigUInt.Word
    public typealias Index = Swift.Int
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias Iterator = Swift.IndexingIterator<DCloudBigInt.BigUInt.Words>
    public typealias SubSequence = Swift.Slice<DCloudBigInt.BigUInt.Words>
  }
  public var words: DCloudBigInt.BigUInt.Words {
    get
  }
  public init<Words>(words: Words) where Words : Swift.Sequence, Words.Element == Swift.UInt
}
extension DCloudBigInt.BigInt {
  public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.CountableRange<Swift.Int>
    public var count: Swift.Int {
      get
    }
    public var indices: DCloudBigInt.BigInt.Words.Indices {
      get
    }
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      get
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<DCloudBigInt.BigInt.Words>
    public typealias SubSequence = Swift.Slice<DCloudBigInt.BigInt.Words>
  }
  public var words: DCloudBigInt.BigInt.Words {
    get
  }
  public init<S>(words: S) where S : Swift.Sequence, S.Element == Swift.UInt
}
extension DCloudBigInt.BigInt.Sign : Swift.Equatable {}
extension DCloudBigInt.BigInt.Sign : Swift.Hashable {}
